# 목표 (1달, 취업 어필용)

- **대화형 웹앱**: 채팅으로 한국형 **키토 식단 레시피 추천** + **주변(또는 지정 지역) 키토 친화 식당 찾기**.
- **AI 활용 어필 포인트**: LangChain/LangGraph 기반 **에이전트 오케스트레이션**, 임베딩+RAG, 규칙 기반 **Keto Score**, 지도 검색(카카오 로컬 API), 간단한 사용자 프로필/알레르기 반영.
- **현실적 범위**: 전국 확장은 욕심. \*\*강남/역삼(또는 학교 주변)\*\*으로 데모 범위 제한. 크롤링은 최소화(공식 검색 API 우선).

---

## 기능 범위 (MoSCoW)

**Must**

- 채팅 UI: “아침에 먹을만한 한식 키토 뭐 있어?”, “역삼역 근처 키토 가능한 식당 알려줘”
- 레시피 추천: 한국형 메뉴(불고기, 제육, 두부된장국 등) **키토화(keto-ize)** 변환 + 대체재 제안
- 식당 찾기: 카카오 로컬/맵 API로 후보 검색 → **Keto Score**로 정렬 → 지도/리스트
- 기본 프로필: 선호/비선호/알레르기, 목표 칼로리/탄수 제한
- RAG: 소규모 한식 레시피 코퍼스(팀이 큐레이션 30\~80개) + 임베딩 검색

**Should**

- 7일 식단표(아침/점심/저녁) 자동 생성
- 즐겨찾기/최근 대화 저장

**Won’t (이번 스프린트 제외)**

- 전국 실시간 크롤링, 정교한 영양 DB 연동, 결제/회원제, 배달 연동

---

## 추천 아키텍처 (간단/현실 우선)
```
[Web (Vite+React, TS)] ──────► [API (FastAPI)] ──► [Agent Orchestrator (LangGraph)]
         │                         │                        │
         │                         │                        ├─► RecipeRAG Tool (Postgres + pgvector @ Supabase)
         │                         │                        ├─► PlaceSearch Tool (Kakao Local API)
         │                         │                        ├─► KetoScore Tool (rule-based)
         │                         │                        └─► Profile/Plans/Logs (Postgres @ Supabase)
         │
         └── Kakao Map JS SDK / React Query / Zustand (경량)
```
- **프론트**: Vite + React + TanStack Query, Kakao Map JS SDK, UI 라이브러리(Shadcn/UI or MUI)
- **백엔드**: **FastAPI(Python)** + **LangGraph**(에이전트 플로우) + LangChain 도구
- **DB/호스팅**: **Supabase(Postgres 15+)**
  - **pgvector** 확장으로 임베딩 저장/유사도 검색
  - **Row Level Security(RLS)**는 데모에선 비활성 또는 간단 정책(서버키 사용)
  - PostgREST(자동 API) 또는 서버에서 직접 **SQLAlchemy/psycopg** 접근
- **임베딩/LLM**: OpenAI 또는 등가 모델(비용/정책 고려)
- **외부 API**: Kakao Local/Maps (검색/좌표/카테고리), (옵션) Naver Geocode

> 팀 역량/시간을 고려해 **Vite(프론트)** + **FastAPI(백)** 분리 유지. 데이터는 Supabase에 단일화하여 관리/로그인/파일 등 확장 여지 확보.

---

## 데이터 모델 (Postgres/Supabase, 최소셋)
**핵심 테이블**: `users`, `recipes`, `recipe_embeddings(pgvector)`, `places_cache`, `messages`, `plans`, `weights`

```sql
-- 1) 확장
create extension if not exists vector;

-- 2) 사용자(데모용 최소)
create table if not exists users (
  id uuid primary key default gen_random_uuid(),
  nickname text,
  goals_kcal int,
  goals_carbs_g int,
  allergies text[] default '{}',
  dislikes text[] default '{}',
  created_at timestamptz default now()
);

-- 3) 레시피
create table if not exists recipes (
  id uuid primary key default gen_random_uuid(),
  title text not null,
  tags text[] default '{}',
  ketoized boolean default false,
  macros jsonb,                 -- {kcal,carb,protein,fat}
  source text,
  created_at timestamptz default now()
);

-- 4) 레시피 임베딩(문서 분할 저장)
create table if not exists recipe_embeddings (
  recipe_id uuid references recipes(id) on delete cascade,
  chunk_idx int not null,
  content text not null,
  embedding vector(1536) not null,
  primary key (recipe_id, chunk_idx)
);
-- 코사인 검색 인덱스(IVFFLAT)
create index if not exists recipe_embeddings_cosine_idx
  on recipe_embeddings using ivfflat (embedding vector_cosine_ops) with (lists = 100);

-- 5) 장소 캐시(카카오 검색 결과 보관)
create table if not exists places_cache (
  place_id text primary key,
  name text,
  address text,
  category text,
  lat double precision,
  lng double precision,
  keto_score int,
  last_seen_at timestamptz
);

-- 6) 대화 로그
create table if not exists messages (
  id bigserial primary key,
  session_id uuid,
  user_id uuid,
  role text check (role in ('user','assistant')),
  content text,
  tool_calls jsonb,
  created_at timestamptz default now()
);

-- 7) 캘린더/플랜
create table if not exists plans (
  id uuid primary key default gen_random_uuid(),
  user_id uuid not null references users(id) on delete cascade,
  date date not null,
  slot text not null check (slot in ('breakfast','lunch','dinner','snack')),
  type text not null check (type in ('recipe','place')),
  ref_id text not null,
  title text not null,
  location jsonb,   -- {name,address}
  macros jsonb,     -- optional
  notes text,
  status text not null default 'planned' check (status in ('planned','done','skipped')),
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);
create unique index if not exists uniq_plan_user_date_slot on plans(user_id, date, slot);

-- 8) 선택: 체중 기록
create table if not exists weights (
  user_id uuid references users(id) on delete cascade,
  date date not null,
  weight_kg numeric(5,2),
  primary key (user_id, date)
);
```

> 임베딩 차원(여기선 1536)은 사용하는 모델에 맞춰 조정. Supabase SQL Editor에서 그대로 실행하면 됨.

---

## API 설계 (요지)

- `POST /chat`: { message, location?, radiusKm?, profile? } → 스트리밍 응답(텍스트 + tool 이벤트)
- `GET /places`: { q, lat, lng, radius } → [{ name, address, keto\_score, tips }]
- `POST /mealplan`: { days:7, kcalTarget, carbsMax, allergies, dislikes } → 표 데이터

### 예시 응답(레스토랑)

```json
{
  "name": "서촌숯불구이",
  "address": "서울 강남구…",
  "keto_score": 83,
  "why": ["밥/면 제외 주문 가능", "삼겹/목살 위주", "양념 설탕 주의"]
}
```

---

## LangGraph 에이전트 설계

**노드**

1. `router`: 의도 분류(레시피/식당/식단표/스몰톡)
2. `recipe_rag`: 임베딩 검색 → 히트 적으면 키토화 생성(prompt) → 간단 매크로 추정
3. `place_search`: Kakao Local API 호출 → 카테고리/키워드 필터 → Keto Score 계산 → 상위 N 반환
4. `mealplan`: 7일 표 자동 생성(프로필 제약 반영)
5. `memory`: 알레르기/비선호/목표값 업데이트

**엣지**: `router` → 해당 도구 → `answer`

### (의사코드)

```python
from langgraph.graph import Graph

workflow = Graph()
workflow.add_node("router", router_fn)
workflow.add_node("recipe_rag", recipe_rag_fn)
workflow.add_node("place_search", place_search_fn)
workflow.add_node("mealplan", mealplan_fn)
workflow.add_node("memory", memory_fn)

workflow.add_edge("router", "recipe_rag")
workflow.add_edge("router", "place_search")
workflow.add_edge("router", "mealplan")
workflow.add_edge("router", "memory")

app = workflow.compile()
```

---

## Keto Score (간단 규칙, 0\~100)

```
score = 50
+20 단백질 중심(삼겹/목살/등심/회/닭다리/계란/버터/치즈)
+10 채소 반찬 위주(나물/샐러드/쌈)
-25 탄수 주식 포함(밥/면/떡/빵/전분, 버거 번, 김밥류)
-10 양념 당류(고추장 양념/설탕 양념/불고기 단맛)
+10 밥/면 제외 주문 가능(“밥 빼주세요”, “쌈추가” 안내)
+5  지방 보강 가능(버터·올리브오일 추가, 치즈 토핑)
clamp 0..100
```

> 규칙은 상수로 코드화(설명 가능성↑). 프롬프트 기반 점수보다 **재현성** 좋음.

---

## 프롬프트 설계(요지)

- **시스템**: “너는 한국형 키토 식단 코치. 탄수 제한과 알레르기, 비선호 준수. 결과는 JSON 스키마 준수.”
- **레시피**: 입력 재료/요청 스타일 반영 → **한국 식재료/양념** 우선 → 대체재(두부면, 콜리플라워 라이스 등) 제안 → **조리단계 5\~8**로 제한 → **매크로 근거**(주요 재료 g 기준 추정)
- **식당**: 요청 위치/반경/카테고리 추출 → 검색 질의 생성(“구이”, “샤브샤브”, “샐러드”, “회”, “스테이크”) → Keto Score 및 주의사항(양념 설탕/밥 제외) 설명

---

## 프론트 구조 (Vite + React)

```
src/
  pages/
    Chat.tsx        # 메인
    Map.tsx         # 지도/리스트
  components/
    ChatBubble.tsx
    Composer.tsx
    RecipeCard.tsx
    PlaceCard.tsx
    MealPlanTable.tsx
  lib/
    api.ts          # fetchers (TanStack Query)
    schema.ts       # zod 스키마
  store/
    profile.ts      # 선호/알레르기 등
```

- **React Query**: /places, /mealplan 요청 캐싱 → 재질의/로딩 개선.
- **카카오맵**: 지도 + 마커 + 인포윈도우, 리스트 hover 연동.

---

## FastAPI 엔드포인트 (요지)

```python
from fastapi import FastAPI
app = FastAPI()

@app.post("/chat")
def chat(req: ChatIn):
    route = router(req.message)
    if route == "recipe":
        return recipe_rag(req)
    if route == "place":
        return place_search(req)
    if route == "mealplan":
        return mealplan(req)
    return smalltalk(req)
```

### Kakao Local 예시(의사코드)

```python
import httpx, os
KAKAO_KEY = os.getenv("KAKAO_REST_KEY")

async def kakao_search(q, lat, lng, radius):
    headers={"Authorization": f"KakaoAK {KAKAO_KEY}"}
    url = "https://dapi.kakao.com/v2/local/search/keyword.json"
    params={"query": q, "x": lng, "y": lat, "radius": int(radius*1000)}
    async with httpx.AsyncClient() as c:
        r = await c.get(url, params=params, headers=headers, timeout=8)
    return r.json()
```

---

## 개발 일정 (4주 스프린트, 캘린더 포함)
**Week 1**
- Supabase 프로젝트 생성 → **pgvector 확장** 설치, 위 **DDL**로 스키마/인덱스 구축
- Vite/React 스켈레톤 + Kakao Map 표시, FastAPI `/health`
- 레시피 시드 30–80개를 `recipes`/`recipe_embeddings`에 적재(스크립트)
- 프론트 데이터 패턴 정리: React Query(fetchers), 상태 관리(경량) 세팅

**Week 2**
- LangGraph 플로우(라우터→`recipe_rag`/`place_search`/`mealplan`)
- **RAG 파이프라인(pgvector)**: 임베딩 생성 → 유사도 검색(SQL) → JSON 포맷 고정
- Keto Score 규칙 구현 + 단위 테스트
- 캘린더 설계 확정(슬롯/데이터모델/엔드포인트 스펙)

**Week 3**
- Kakao Local 통합, 리스트/지도 연동, 스코어 정렬, 필터(밥 제외 가능 등)
- 프로필(알레르기/비선호) 입력 + 세션 메모리 반영
- 7일 식단표 생성 + 테이블/CSV 다운로드
- **캘린더 구현**: 월/주/일 UI, 계획 저장/불러오기(`POST /plan/item`, `GET /plan/range`), 완료/스킵 토글
- **부가 기능**: 주간 ICS 내보내기(`GET /plan/week/:start/export.ics`), 쇼핑리스트(`GET /plan/week/:start/shopping-list`)

**Week 4**
- 프롬프트/검증 튜닝, 오류 UX, 스키마 검증(zod/pydantic)
- **캘린더 보강**: 통계(이행률, 평균 탄수, 외식 비중, 선택: 체중 트렌드)
- 데모 스크립트/리드미/스크린샷 + 간단 벤치(응답시간, 실패율)
- 최종 리허설: 3가지 시나리오(아침 추천/역삼 식당/알레르기 반영 식단표 + 캘린더 기록)

---

## 역할 분담 (예시 5인)

- **FE 리드**: 채팅/지도 UI, React Query, 상태 관리
- **BE/에이전트**: FastAPI, LangGraph, 도구 구현
- **데이터/RAG**: 레시피 코퍼스 수집/정제, 임베딩/평가
- **지도/검색**: Kakao API, 스코어링/필터, 장소 캐시
- **PM/QA**: WBS/이슈/PRD, 테스트 시나리오, 발표 자료

---

## 데모 체크리스트(합격 기준)

- 2.5s 내 첫 토큰, 6s 내 최종 답변(데모 질의 기준)
- 레시피 카드: 재료/조리/매크로/키토화 팁 1\~2줄
- 식당 카드: Keto Score, 이유 2\~3개, ‘밥 제외 요청’ 등 팁
- 프로필 반영: ‘갑각류 알레르기’ 넣으면 관련 메뉴 제외
- 크래시/빈응답 0회, 에러 메시지 한국어/친절

---

## .env 예시
```
SUPABASE_URL=...
SUPABASE_ANON_KEY=...
SUPABASE_SERVICE_ROLE_KEY=...   # 서버 전용(보관 주의)
DATABASE_URL=postgresql+psycopg://postgres:password@db.xxxxx.supabase.co:5432/postgres
OPENAI_API_KEY=...
EMBEDDING_MODEL=text-embedding-3-small
KAKAO_REST_KEY=...
```

---

## 빠른 시작(개발용 스크립트 예)
**백엔드**
```bash
uv venv && source .venv/bin/activate
pip install fastapi uvicorn langchain langgraph sqlalchemy psycopg[binary] pgvector pydantic httpx supabase
uvicorn app.main:app --reload
```

**프론트**
```bash
pnpm create vite@latest ketocoach --template react-ts
pnpm add @tanstack/react-query zod
pnpm dev
```

### pgvector 검색 SQL (예시)
```sql
-- 질의 임베딩(:qvec)을 기준으로 코사인 유사도 상위 5개 조각을 찾고, 레시피 메타와 조인
select r.id, r.title, e.content,
       1 - (e.embedding <=> :qvec) as score
from recipe_embeddings e
join recipes r on r.id = e.recipe_id
order by e.embedding <=> :qvec
limit 5;
```

---

## 면접 어필 포인트

- 에이전트 오케스트레이션(LangGraph) 노드/엣지 설계와 **도구 호출 로그** 스크린샷
- RAG(임베딩→유사도 검색→근거 제공) **근거 패널**
- 재현 가능한 **Keto Score** 규칙 코드 + 단위테스트 링크
- 지도 검색/정렬/필터링 UX, 카카오 API 실무 연동 경험

---

## 리스크/대안

- 외부 API 한도 → 요청 캐시/데모 계정 분리
- 영양 정확도 → 추정임 명시 + 간단 신뢰구간 표현(±)
- 데이터 부족 → 팀 수집 레시피 최소 30개, 나머지는 LLM 보완

---

### 부록 A. 레시피 JSON 스키마 (요지)

```json
{
  "title": "돼지불고기(키토 버전)",
  "ingredients": [{"name":"목살","amount":200,"unit":"g"}, {"name":"양파","amount":50,"unit":"g"}],
  "steps": ["..."],
  "macros": {"kcal":520, "carb":12, "protein":34, "fat":36},
  "tips": ["설탕 대신 에리스리톨", "밥 대신 상추쌈"],
  "allergen_flags": ["soy"],
  "ketoized": true
}
```

### 부록 B. 라우터 프롬프트(요지)

"사용자 메시지를 {intent: recipe|place|mealplan|memory|other, slots:{…}} JSON으로 분류하라."

### 부록 C. 테스트 시나리오

1. “**역삼역 500m** 안에서 **샤브샤브** 중 키토로 먹기 좋은 곳?”
2. “**난 우유 알레르기**, **탄수 30g 이하**, **오늘 점심**에 가능한 한식 키토 레시피 추천”
3. “**7일 식단표** 만들어줘. **돼지고기 선호**, **닭 싫어**"



---

## 캘린더/플래너 기능 설계 (일/월 계획 + 기록)

**목표**: 추천에 그치지 않고 **날짜별로 레시피/식당 계획**을 저장하고, 실행 여부(완료/스킵) 기록, 주·월 단위 요약/통계를 제공.

### 사용자 시나리오

1. **계획**: 채팅으로 받은 레시피/식당 카드에서 `📅 일정에 추가` → 날짜/식사슬롯(아점저/스낵) 선택 → 저장.
2. **기록**: 당일 카드에서 `완료`/`스킵` 토글, 간단 메모(맛/컨디션/혈당).
3. **보기**: 월/주 달력에서 하루를 클릭하면 아·점·저 슬롯 카드 리스트.
4. **내보내기**: 한 주 계획을 **ICS** 파일로 다운로드(구글/네이버 캘린더에 가져오기), 또는 Google Calendar 템플릿 링크로 열기.
5. **쇼핑리스트**: 한 주 레시피 재료를 집계해서 장보기 리스트 생성.
6. **통계**: 주간 총/평균 매크로(탄/단/지), 계획 대비 이행률(%), 외식 비중.

### 데이터 모델 (Postgres)
**plans / weights (SQL DDL)**
```sql
-- plans: 하루 4슬롯(아/점/저/스낵) 한 개만 허용
create table if not exists plans (
  id uuid primary key default gen_random_uuid(),
  user_id uuid not null references users(id) on delete cascade,
  date date not null,
  slot text not null check (slot in ('breakfast','lunch','dinner','snack')),
  type text not null check (type in ('recipe','place')),
  ref_id text not null,
  title text not null,
  location jsonb,
  macros jsonb,
  notes text,
  status text not null default 'planned' check (status in ('planned','done','skipped')),
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);
create unique index if not exists uniq_plan_user_date_slot on plans(user_id, date, slot);

create table if not exists weights (
  user_id uuid references users(id) on delete cascade,
  date date not null,
  weight_kg numeric(5,2),
  primary key (user_id, date)
);
```

### API 설계

- `GET /plan/range?start=YYYY-MM-DD&end=YYYY-MM-DD` → 일자별 슬롯 묶음
- `POST /plan/item` → 계획 추가(중복 시 upsert)
- `PATCH /plan/item/:id` → `status`/`notes` 수정
- `DELETE /plan/item/:id` → 계획 삭제
- `POST /plan/commit` → 채팅 제안(7일 식단표 등)을 **일괄 저장**
- `GET /plan/week/:start/export.ics` → 한 주 계획 ICS 다운로드
- `GET /plan/week/:start/shopping-list` → 재료 집계표(JSON/CSV)

**예시** `POST /plan/item`

```json
{
  "date":"2025-09-15",
  "slot":"lunch",
  "type":"recipe",
  "refId":"66f2...",
  "title":"닭다리 구이 샐러드",
  "macros": {"kcal":480, "carb":10, "protein":38, "fat":30}
}
```

### FastAPI 예시(요지)

```python
from fastapi import APIRouter
from pydantic import BaseModel
from datetime import date

router = APIRouter(prefix="/plan")

class PlanIn(BaseModel):
    date: str  # YYYY-MM-DD
    slot: str  # breakfast|lunch|dinner|snack
    type: str  # recipe|place
    refId: str
    title: str
    macros: dict | None = None
    location: dict | None = None

@router.get("/range")
async def get_range(start: str, end: str, user_id: str):
    # find plans for user within [start, end]
    ...

@router.post("/item")
async def upsert_item(p: PlanIn, user_id: str):
    # unique key: (user_id, p.date, p.slot)
    ...

@router.patch("/item/{plan_id}")
async def update_item(plan_id: str, patch: dict, user_id: str):
    ...
```

### ICS 내보내기 (주요 부분)

```python
from icalendar import Calendar, Event
from datetime import datetime, timedelta
import pytz

seoul = pytz.timezone("Asia/Seoul")
cal = Calendar()
for item in week_items:
    start = seoul.localize(datetime.fromisoformat(item["date"])).replace(hour=12, minute=0)
    end = start + timedelta(hours=1)
    ev = Event()
    ev.add('summary', f"[Keto] {item['slot']} · {item['title']}")
    ev.add('dtstart', start)
    ev.add('dtend', end)
    if item.get('location'): ev.add('location', item['location'].get('address',''))
    cal.add_component(ev)
# return Response(cal.to_ical(), media_type='text/calendar')
```

**Google Calendar 템플릿 링크(예)**

```
https://calendar.google.com/calendar/render?action=TEMPLATE&text=[Keto]%20점심%20-%20닭다리%20구이&dates=20250915T030000Z/20250915T040000Z&details=탄수%2030g%20이하%20권장&location=서울%20강남...
```

> 데모에서는 **앱 내 캘린더 + ICS 다운로드**만으로 충분. 외부 캘린더 동기화는 템플릿 링크로 가볍게.

### 프론트엔드(UI) 구조

- **MonthlyGrid**(react-day-picker 권장, 가볍고 접근성 좋음)
- **DayPanel**: 아/점/저/스낵 4 슬롯 카드 리스트(추가/수정/삭제)
- **PlanAction**: 레시피/식당 카드에 `📅 일정에 추가` 버튼 → 모달에서 날짜·슬롯 선택
- **상태관리**: React Query `useQuery(['plan', start, end], ...)` + `useMutation`(옵티미스틱 업데이트)
- **토글**: `done/skipped` 시 카드 스타일 변경 및 통계 반영

**DayPanel 예시 (TSX)**

```tsx
function DayPanel({ date }: { date: string }) {
  const { data } = useQuery({ queryKey: ['plan', date], queryFn: () => api.getDay(date) })
  const m = useMutation(api.upsertPlan)
  const slots = ['breakfast','lunch','dinner','snack'] as const
  return (
    <div className="grid grid-cols-1 gap-3">
      {slots.map(s => (
        <SlotCard key={s} slot={s} item={data?.[s]}
          onAdd={(item)=>m.mutate({...item, date, slot:s})}
          onToggleStatus={(id,status)=>api.patchItem(id,{status})}
        />
      ))}
    </div>
  )
}
```

### 쇼핑리스트(주간 집계) 알고리즘(요지)

1. 주간 `plans` 중 `type=recipe`를 조회 → `recipes.refId`로 join
2. `ingredients[{name, amount, unit}]`를 **이름 단위로 그룹**
3. 단위 통일(가능 시 g/ml ↔ 개수 변환 테이블) 후 **합산**
4. 결과를 카테고리(육류/채소/유제품/양념)로 정렬 → JSON/CSV 반환

### 통계(간단 지표)

- `이행률` = done / planned
- `평균 탄수` = Σcarb / done일수 (슬롯 기준 평균도 가능)
- `외식비중` = type=place 비율
- (선택) `체중 추세`: `weights`와 조합해 스파크라인

### 보안/시간대

- DB에는 **로컬 날짜 문자열**(Asia/Seoul 기준)로 저장하고, 시간은 기본 슬롯별 고정(예: 점심 12:00) → ICS 생성 시만 시각화.

---



---

## AI 기술 매핑 (어디에 어떤 AI가 들어가는가)

> 한 달 MVP 기준 **필수(★)** / 선택(☆) 표기

| 기능                   | AI 기술/기법                     | 라이브러리/모델(예시)                                                    | 입력 → 출력                              | 비고                      |
| -------------------- | ---------------------------- | --------------------------------------------------------------- | ------------------------------------ | ----------------------- |
| **의도 라우팅(★)**        | LLM 분류 + 구조화 출력(JSON)        | LangGraph 노드 + LLM(function/JSON mode)                          | 사용자 발화 → `{intent, slots}`           | 규칙/키워드 백업 로직 병행 가능      |
| **슬롯 추출/NER(★)**     | LLM 기반 슬롯 필링(지역/반경/카테고리/제약)  | LangChain `StructuredOutputParser` 또는 pydantic                  | “역삼역 근처 샤브샤브” → `{loc, radius, cat}` | 간단 regex로 보조            |
| **레시피 RAG(★)**       | 임베딩 검색 + 생성                  | 임베딩(`text-embedding-3-small` 등), 벡터DB(pgvector @ Supabase), LLM | 질의/프로필 → 근거 레시피 조각 → 키토 버전 제안        | 답변에 근거(레시피 출처) 포함       |
| **키토화(keto-ize)(★)** | 규칙+LLM 보정(프롬프트 엔지니어링)        | LangGraph 툴(규칙 함수) + LLM                                        | 일반 메뉴 → 대체재/조리법 JSON                 | 설탕→에리스리톨, 밥→상추쌈 등 규칙 우선 |
| **식당 검색 질의 개선(★)**   | LLM 질의 리라이팅                  | LLM                                                             | 자연어 → Kakao 카테고리 키워드                 | “고기 많은 한식”→“구이/샤브/회”    |
| **결과 정렬(★)**         | 규칙 기반 **Keto Score**         | 코드(비AI)                                                         | 장소 후보 → 0\~100                       | 재현성/설명 가능성 확보           |
| **결과 재랭킹(☆)**        | 크로스 인코더 재랭킹                  | `cross-encoder/ms-marco-MiniLM-L-6-v2` 등                        | 상위 20 → 상위 5                         | 한국어 성능 확인 후 적용          |
| **식단표 생성(★)**        | 제약 조건 LLM 플래닝(2-pass 검증)     | LangGraph(검증 엣지) + LLM                                          | 선호/알레르기/탄수한도 → 7일 표                  | 1차 생성 → 2차 검증/수정 루프     |
| **매크로 산출(★)**        | 테이블 룩업 + 합산(비AI) / LLM 보간(☆) | 내부 영양 테이블(JSON/CSV) / LLM                                       | 재료 리스트 → kcal/carb/protein/fat       | 누락 항목만 LLM 추정           |
| **프로필 개인화(★)**       | RAG 프리필터 + 컨텍스트 삽입           | 임베딩 쿼리 프리필터                                                     | 알레르기/비선호 → 결과 필터링                    | 금지 재료 hard filter       |
| **관찰/튜닝(★)**         | 평가 프롬프트 세트 + 로그 트레이싱         | LangGraph run logs, 간단 평가 스크립트                                  | 입력→도구호출/응답                           | 실패 케이스 재학습/프롬프트 보정      |

### 데이터 흐름 요약

1. **사용자 발화** → (의도 라우팅/슬롯 추출) → 분기
2. **레시피**: (임베딩 검색) → 근거 추출 → (키토화) → (매크로 산출) → 카드
3. **식당**: (LLM 리라이팅) → Kakao 검색 → (Keto Score 정렬) → (재랭킹 옵션) → 카드
4. **식단표**: (LLM 플래닝) → (검증 엣지로 제약 확인/수정) → 캘린더에 `plans` 저장

### LangGraph 노드별 AI 사용

- `router`(LLM) → `recipe_rag`(임베딩+LLM) / `place_search`(LLM리라이팅+규칙스코어) / `mealplan`(LLM+검증) / `memory`(비AI 업서트)
- 각 노드는 **구조화 출력(JSON/Pydantic)** 강제 → 백엔드에서 스키마 검증

### 최소 모델 세트(비용/시간 최적)

- **LLM**: 1개(생성/분류 겸용)
- **임베딩**: 1개(레시피 전용 인덱스)
- **벡터DB**: pgvector(Postgres/Supabase)
- **재랭킹**: 미도입(MVP) → 품질 이슈 있을 때만 추가

### 품질·안정화 체크리스트

- 모든 LLM 응답은 **pydantic**으로 검증, 실패 시 **자동 재시도**
- RAG는 **MMR**와 `top_k`=5 기본, 근거 스니펫 2\~3개 제한
- 키토화 규칙은 **유닛 테스트**로 예외 방지(예: "국수류 무조건 -25")
- 캘린더 저장 전, 식단표의 각 슬롯이 **알레르기/탄수 한도** 위반 없는지 체크

